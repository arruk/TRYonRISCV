$version Generated by VerilatedVcd $end
$date Mon Jun 10 19:15:45 2024
 $end
$timescale   1ps $end

 $scope module TOP $end
  $var wire 32 I a [31:0] $end
  $var wire 32 J b [31:0] $end
  $var wire  1 K cin $end
  $var wire  1 M cout $end
  $var wire 32 L s [31:0] $end
  $scope module cla_adder32b $end
   $var wire  4 $ G [3:0] $end
   $var wire  4 # P [3:0] $end
   $var wire 32 I a [31:0] $end
   $var wire 32 J b [31:0] $end
   $var wire  4 % c [3:0] $end
   $var wire  1 K cin $end
   $var wire  1 M cout $end
   $var wire 32 L s [31:0] $end
   $scope module a0 $end
    $var wire  1 ' G $end
    $var wire  1 & P $end
    $var wire  8 N a [7:0] $end
    $var wire  8 ) and_w [7:0] $end
    $var wire  8 O b [7:0] $end
    $var wire  9 - c [8:0] $end
    $var wire  1 K cin $end
    $var wire  1 ( cout $end
    $var wire  8 + g [7:0] $end
    $var wire  8 * or_w [7:0] $end
    $var wire  8 , p [7:0] $end
    $var wire  8 P s [7:0] $end
    $var wire  8 Q xor_w [7:0] $end
   $upscope $end
   $scope module a1 $end
    $var wire  1 0 G $end
    $var wire  1 / P $end
    $var wire  8 R a [7:0] $end
    $var wire  8 2 and_w [7:0] $end
    $var wire  8 S b [7:0] $end
    $var wire  9 6 c [8:0] $end
    $var wire  1 . cin $end
    $var wire  1 1 cout $end
    $var wire  8 4 g [7:0] $end
    $var wire  8 3 or_w [7:0] $end
    $var wire  8 5 p [7:0] $end
    $var wire  8 T s [7:0] $end
    $var wire  8 U xor_w [7:0] $end
   $upscope $end
   $scope module a2 $end
    $var wire  1 9 G $end
    $var wire  1 8 P $end
    $var wire  8 V a [7:0] $end
    $var wire  8 ; and_w [7:0] $end
    $var wire  8 W b [7:0] $end
    $var wire  9 ? c [8:0] $end
    $var wire  1 7 cin $end
    $var wire  1 : cout $end
    $var wire  8 = g [7:0] $end
    $var wire  8 < or_w [7:0] $end
    $var wire  8 > p [7:0] $end
    $var wire  8 X s [7:0] $end
    $var wire  8 Y xor_w [7:0] $end
   $upscope $end
   $scope module a3 $end
    $var wire  1 B G $end
    $var wire  1 A P $end
    $var wire  8 Z a [7:0] $end
    $var wire  8 D and_w [7:0] $end
    $var wire  8 [ b [7:0] $end
    $var wire  9 H c [8:0] $end
    $var wire  1 @ cin $end
    $var wire  1 C cout $end
    $var wire  8 F g [7:0] $end
    $var wire  8 E or_w [7:0] $end
    $var wire  8 G p [7:0] $end
    $var wire  8 \ s [7:0] $end
    $var wire  8 ] xor_w [7:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b1111 #
b0001 $
b1111 %
1&
1'
1(
b00000001 )
b11111111 *
b11111111 +
b11111111 ,
b111111110 -
1.
1/
00
11
b00000000 2
b11111111 3
b00000000 4
b11111111 5
b111111111 6
17
18
09
1:
b00000000 ;
b11111111 <
b00000000 =
b11111111 >
b111111111 ?
1@
1A
0B
1C
b00000000 D
b11111111 E
b00000000 F
b11111111 G
b111111111 H
b11111111111111111111111111111111 I
b00000000000000000000000000000001 J
0K
b00000000000000000000000000000000 L
1M
b11111111 N
b00000001 O
b00000000 P
b11111110 Q
b11111111 R
b00000000 S
b00000000 T
b11111111 U
b11111111 V
b00000000 W
b00000000 X
b11111111 Y
b11111111 Z
b00000000 [
b00000000 \
b11111111 ]
#1
#2
#3
#4
#5
#6
#7
#8
#9
